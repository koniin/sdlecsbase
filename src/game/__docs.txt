

 next:
    = Goal: 
	- simple overworld/delve map
	
	- reduce game_controller size (move out systems and creation ?)
		- game_controller => combat_controller
		- make a "gamestate struct" 
		- create the player mothership and fighters from the game state
		
	- spawn in ships at start of battle (warp them in)
		- add ships to one list, move them in and then move to correct list?
		- so two vectors, one with ships and one with data struct (spawn_time, timer)
		  when timer is up you add the ship to the other list (e.g. _fighter_ships)
		  and spawn the warp effect?

	- some random spacing of nodes on world_map
		- make a function to get rendering coordinates for any node x, y in global scope (int local coordinate space)
		- get spacing based on x,y ?
		- node x,y is then: global x + x_max_distance * (-1 to 1 based on x, y), where x_max_distance is something like 10 ?

	- Simple ship to ship battle
		- defensive measures? like anti missiles, beam deflector, whatevs
		- hit/miss/accuracy/crit
		- damage range for weapons? 8-12 etc
		- shield + armor combo (shield regenerates)
		- borderlands weapons [ damage, accuracy, reload time | fire rate (shots/s), projectile count (for burst etc) ]
		- borderlands shield [ regenerates slow ]
			shield regeneration starts after x amount of time
			so if you don't get hit it will start after some time
			"abilities" to not take damage
			"abilities/items" to buff shields (regeneration amount, time, start time etc)
		- you could have different "deployment zones" like front, middle and back and that is the distance to the enemy ships
			which could be good depending on what kind of stats the ship hans

Dynamic components
	- dynamic component = move the entity to another list
	- have a linked thing in another list or add the entity reference to another list 
	- or add an item to another list with reference to the entity somehow


Click handlers
================
	(Note: I also want to handle mouse overs, so your method may differ if you don't)
	I define the following components:
	MouseOverTarget, MouseOver, ClickTarget, Clicked, ClickHandled

	I have the following systems:
	MouseOverSystem - goes through all MouseOverTarget entities and adds/removes MouseOver where appropriate
	ClickSystem - goes through MouseOver+ClickTarget and adds Clicked if LMB was pressed.

	then for each kind of clickable entity in my game I have systems like
	CardMouseOverSystem - goes through all Card+MouseOver, (e.g. highlights the card)
	CardClickSystem - goes through all Card+Clicked+Not(ClickHandled), does whatever it needs (this is your "OnClick" method) and adds ClickHandled. 
    (For example, in my case it adds a Dragged component for Drag&Drop).

	Oh, and the ClickSystem also cleans up Clicked+ClickHandled pairs (just removes them).

	I would assume when the ECS matures you will get all but the entity-kind-specific systems built in (just like you don't have to call OnClick yourself in the UI system). 
    Or maybe they will come up with a better method. 
